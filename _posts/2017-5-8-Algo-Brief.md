---
layout: post
title: "Algo Brief"
excerpt: "Brief introduction of Algorithms"
date: 2017-05-08 22:28:18 +08:00
tags: [Algo]
---
# 综述:
软件考研内容要求掌握的抽象能力分为数据结构和算法两部分,数据结构是栈（Stack）、队列（Queue）和向量（Vector）;算法则以树(tree),查找(search),排序(sort),图为主类.以下是具体分类:

## 一、栈（Stack）、队列（Queue）和向量（Vector）

单链表,双向链表,环形链表,带哨兵节点的链表;
栈的基本概念和性质,栈ADT及其顺序,链接实现;栈的应用;栈与递归;
队列的基本概念和性质,队列ADT及其顺序,链接实现;队列的应用;
向量基本概念和性质;向量ADT及其数组、链接实现;

## 二、树

内容: 树的基本概念和术语;树的前序,中序,后序,层次序遍历;
二叉树及其性质;普通树与二叉树的转换;
树的存储结构,标准形式;完全树(complete tree)的数组形式存储;
树的应用,Huffman树的定义与应用;

## 三、查找(search)

内容: 查找的基本概念;对线性关系结构的查找,顺序查找,二分查找;
Hash查找法,常见的Hash函数(直接定址法,随机数法),hash冲突的概念, 解决冲突的方法(开散列方法/拉链法,闭散列方法/开址定址法),二次聚集现象;
BST树定义,性质,ADT及其实现,BST树查找,插入,删除算法;
平衡树 (AVL) 的定义,性质,ADT及其实现,平衡树查找,插入算法,平衡因子的概念;
优先队列与堆,堆的定义,堆的生成,调整算法;范围查询;

## 四、排序

内容: 排序基本概念;插入排序,希尔排序,选择排序,快速排序,合并排序,基数排序等排序算法基本思想,算法代码及基本的时间复杂度分析

## 五、图

内容： 图的基本概念;图的存储结构,邻接矩阵,邻接表;图的遍历,广度度优先遍历和深度优先遍历;最小生成树基本概念,Prim算法,Kruskal算法;最短路径问题,广度优先遍历算法,Dijkstra算法,Floyd算法;拓扑

>[资料来源](http://www.software.fudan.edu.cn/software/index.html#/dynamic/recruit/95)  

***

我将带着大家按照从浅入深的方法攻克这一部分,希望大家能够奋斗.
我们先从排序开始一步一步走下去.因为大家对排序的概念比较熟练,所以今天就先从冒泡排序,选择排序,插入排序扩展到快速排序  
使用语言为C++;
我们先假定要排得数组为 

	int NeedSort[10]={10,9,8,7,6,5,4,3,2,1};  

想象我们手中有这样十个扑克,你会怎样对他们排序呢
那么我们只要从第1最小,然后在后面找牌,找到比这个小的,我们就交换,然后继续,这样一轮下来,第一个牌一定是最小的了,我们在对第二个位置的牌这样下去,直到最后一个,我们就完成了排序,下面看代码,为了方便表示,我一般会写成函数体

	void sort(int *s,int size)		//传入数组的首地址,和大小
	{
		for(int i;i<=size-1;i++)		
			for(int j=i+1;j<=size-1;j++)
			if(s[j]<s[i])				//比较
			swap(s[i],s[j]);			//交换
	}

我们分析这段代码不难发现,我们每一此都进行了多遍不必要的交换,而这耗费了我们大量的时间(我们考虑上亿的牌(数),极端化),仔细想的话,其实我们只要在第i个后面找到一个最小的牌与之交换,就可以缩减时间,对吧?这就是选择排序

	void sort(int *s,int size)
	{
		for(int i;i<=size-1;i++)
		{
			int min=s[i];				//假定第i个最小,记录下标为min
			for(int j=i+1;j<=size-1;j++)
			{	
				if(s[j]<s[min])			
				min=j;			//与后面比较,找到最小的那个并记录下标
			}
			swap(s[i],s[min]);		//将最小的与第i个交换
		}
	}
	
**有没有更好一点办法呢,我们抽牌时,是不是一种排序呢?我们抽到第一个牌,第二次抽到的牌与第一个比较,比他小我们放他前面,反之则放他后面,这样一直下去,也能完成排序.
这个当作课后习题大家自己完成以下,下次文章里我会附上答案,请大家认真思考完成**

上面这三种算法便是大多数老师交语言时会顺带着教的同时不难发现,这三个的复杂度均在O(n^2)左右
那到底有没有更好的算法呢,答案是肯定的,希尔排序,归并排序快速排序都可以达到O(nlgn),
鉴于文章长度,这里只讲快速排序,另外两种放到下次里

* 4 9 2 3 5 7 8 1 6	
对于这样的一串数值,我们可以缩小规模来做,处理一半首先我们找一个值作为分界点,一般我们选择第一个,此例选4
然后我们把比4小的放到他的前面,大的放到他的后面

* 4 9 2 3 5 7 8 1 6	//为了实现这个我们先在右边找到第一个比他小的,再在左侧找到第一个比他大的与刚才那个交换
* 4 1 2 3 5 7 8 9 6	//继续这个过程,我们发现右侧找到3,左侧找3这里
* 3 1 2 4 5 7 8 9 6	//交换

**此时我们发现这堆数已经在4左边全部比4小,右面全部比4
大了,接下来只要对左侧继续这个过程,右侧继续这个过程就可以了**

* 3 1 2 4 5 7 8 9 6
* 1 2 3 4 5 7 8 9 6
* 1 2 3 4 5 7 6 9 8
* 1 2 3 4 5 6 7 9 8
* 1 2 3 4 5 6 7 8 9 

### 完成,下面贴下完整代码  

	#include <iostream>
	using namespace std;
	void QuickSort(int *s,int a,int b)
	{
		if(a>b)	return;
		int i=a,j=b;
		while(i != j)
		{	
			while(s[j]>=s[a] && i<j) j--;
			while(s[i]<=s[a] && i<j) i++;
			if(i<j)
			swap(s[i],s[j]);
		}
		swap(s[a],s[i]);	
		QuickSort(s,a,i-1);
		QuickSort(s,i+1,b);
	}
	int main()
	{	
		int NeedSort[9]={4,9,2,3,5,7,8,1,6};
		QuickSort(NeedSort,0,8);
		for(int i=0;i<9;i++)
			cout<<NeedSort[i]<<" ";
		cout<<endl;
		return 0;
	}


